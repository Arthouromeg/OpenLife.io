<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OpenLife.io (SmoothLife)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="glcanvas" width="768" height="768"></canvas> <!-- square sim size -->
  <script src="https://cdn.jsdelivr.net/gh/chipweinberger/ShaderToyLite.js@main/ShaderToyLite.js"></script>
  <script>
    const bufferASrc = `\
const float PI = 3.14159265;
const float dt = 0.25;
const vec2 r = vec2(10.0, 3.0);
const float b1 = 0.257;
const float b2 = 0.336;
const float d1 = 0.365;
const float d2 = 0.549;
const float alpha_n = 0.028;
const float alpha_m = 0.147;
const float KEY_UP = 38.5/256.0;
const float KEY_DOWN = 40.5/256.0;
const float KEY_SPACE = 32.5/256.0;
#define MOD3 vec3(.1031,.11369,.13787)
float hash13(vec3 p3) { p3 = fract(p3 * MOD3); p3 += dot(p3, p3.yzx+19.19); return fract((p3.x + p3.y)*p3.z); }
float sigmoid_a(float x, float a, float b) { return 1.0 / (1.0 + exp(-(x - a) * 4.0 / b)); }
float sigmoid_b(float x, float b, float eb) { return 1.0 - sigmoid_a(x, b, eb); }
float sigmoid_ab(float x, float a, float b, float ea, float eb) {
  return sigmoid_a(x, a, ea) * sigmoid_b(x, b, eb);
}
float sigmoid_mix(float x, float y, float m, float em) {
  return x * (1.0 - sigmoid_a(m, 0.5, em)) + y * sigmoid_a(m, 0.5, em);
}
float transition_function(vec2 disk_ring) {
  return sigmoid_mix(
    sigmoid_ab(disk_ring.x, b1, b2, alpha_n, alpha_n),
    sigmoid_ab(disk_ring.x, d1, d2, alpha_n, alpha_n),
    disk_ring.y, alpha_m
  );
}
float ramp_step(float steppos, float t) {
  return clamp(t - steppos + 0.5, 0.0, 1.0);
}
vec2 wrap(vec2 position) { return fract(position); }
vec2 convolve(vec2 uv) {
  vec2 result = vec2(0.0);
  for(float dx = -r.x; dx <= r.x; dx++){
    for(float dy = -r.x; dy <= r.x; dy++){
      vec2 d = vec2(dx, dy);
      float dist = length(d);
      vec2 offset = d / iResolution.xy;
      vec2 sp = wrap(uv + offset);
      float weight = texture(iChannel0, sp).x;
      result.x += weight * ramp_step(r.y, dist) * (1.0 - ramp_step(r.x, dist));
      result.y += weight * (1.0 - ramp_step(r.y, dist));
    }
  }
  return result;
}
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  vec2 uv = fragCoord.xy / iResolution.xy;
  vec3 color = texture(iChannel0, uv).xyz;
  vec2 area = PI * r * r;
  area.x -= area.y;
  vec2 norm = convolve(uv) / area;
  color.x += dt * (2.0 * transition_function(norm) - 1.0);
  color.yz = norm;
  color = clamp(color, 0.0, 1.0);
  if(iFrame < 10 || texture(iChannel2, vec2(KEY_SPACE,0.5)).x > 0.5) {
    color = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);
  }
  if(iMouse.z > 0.0) {
    float dst = length((fragCoord.xy - iMouse.xy)/iResolution.xx);
    if(dst <= r.x/iResolution.x) {
      color.x = step((r.y+1.5)/iResolution.x, dst) * (1.0 - step(r.x/iResolution.x, dst));
    }
  }
  if(texture(iChannel2, vec2(KEY_DOWN,5.0/3.0)).x > 0.5) {
    color = vec3(transition_function(uv));
  }
  if(texture(iChannel2, vec2(KEY_UP,0.5)).x > 0.5) {
    color = vec3(0.0);
  }
  fragColor = vec4(color, 1.0);
}`;

    const imageSrc = `\
const vec3 CellColor = vec3(0.2,0.2,0.2);
const vec3 RingColor = vec3(0.0,0.2,0.2);
const vec3 DiskColor = vec3(0.0,0.0,0.0);
void mainImage(out vec4 fragColor, in vec2 fragCoord){
  vec2 uv = fragCoord.xy / iResolution.xy;
  vec4 buf = texture(iChannel0, uv);
  vec3 color = buf.x*CellColor + buf.y*RingColor + buf.z*DiskColor;
  float c = 1.0 - buf.z;
  float c2 = 1.0 - texture(iChannel0, uv + 0.5/iResolution.xy).y;
  color += vec3(.6,.85,1.0)*max(c2*c2 - c*c, 0.0)*4.0;
  fragColor = vec4(color,1.0);
}`;


    const toy = new ShaderToyLite('glcanvas');
    toy.setCommon('');
    toy.setBufferA({ source: bufferASrc, iChannel1: null, iChannel2: 'keyboard' });
    toy.setImage({ source: imageSrc, iChannel0: 'A' });
    toy.play();

    const canvas = toy.canvas;

    function debugMouse(e, clicked) {
      const bounds = canvas.getBoundingClientRect();
      const scaleX = canvas.width  / bounds.width;
      const scaleY = canvas.height / bounds.height;
      const mx = (e.clientX - bounds.left) * scaleX;
      const my = (bounds.bottom - e.clientY) * scaleY;
      toy.setMouse(mx, my, clicked ? 1 : 0);
    }

    canvas.addEventListener('mousedown', e => debugMouse(e, true));
    canvas.addEventListener('mousemove', e => debugMouse(e, e.buttons > 0));
    canvas.addEventListener('mouseup',   e => debugMouse(e, false));

    // Keyboard handling
    const keys = new Uint8Array(256);
    window.addEventListener('keydown', e => keys[e.keyCode] = 1);
    window.addEventListener('keyup',   e => keys[e.keyCode] = 0);
    toy.setKeyboard(keys);
    setInterval(() => toy.setKeyboard(keys), 16);
  </script>
</body>
</html>
